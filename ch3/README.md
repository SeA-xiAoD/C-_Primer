# 3.1
略。
#

# 3.2
见代码。
#

# 3.3
getline直接把空白字符作为字符一次性读入一整行到对应的string中，cin把空白字符作为分隔符使用，读取的时候从非空白字符开始读，遇到空白字符会停止读取。
#

# 3.4
见代码。
#

# 3.5
见代码。
#

# 3.6
见代码。
#

# 3.7
换成char后，赋值后没有将没有被写入原字符串中，所以原字符串没有改变。
#

# 3.8
见代码。
#

# 3.9
不合法，读取到了空的位置，指针飞了。
#

# 3.10
见代码。
#

# 3.11
合法，是const char &类型。
#

# 3.12
(a)不合法，<int>后面需要有一个空格。  
(b)不合法，类型不对应。  
(c)合法。
#

# 3.13
(a)没有元素。  
(b)有10个元素，值为0。  
(c)有10个元素，值为42。  
(d)有1个元素，值为10。  
(e)有2个元素，值为10、42。  
(f)不合法。  
(g)不合法。
#

# 3.14
见代码。
#

# 3.15
见代码。
#

# 3.16
略。
#

# 3.17
见代码。
#

# 3.18
第一行改为vector<int> ivec(1)。
#

# 3.19
(1)vector<int> vi(10, 42);  
(2)vector<int> vi{42, 42, 42, 42 ,42, 42, 42, 42, 42 ,42};  
(3)vector<int> vi = {42, 42, 42, 42 ,42, 42, 42, 42, 42 ,42};  
第一种更好，代码量少。
#

# 3.20
见代码。
#

# 3.21
见代码。
#

# 3.22
<pre><code>for(auto it = text.begin(); it != text.end() && !it->empty(); it++)
{
    *it = toupper(*it);
}</code></pre>
#

# 3.23
见代码。
#

# 3.24
见3.21。
#

# 3.25
见代码。
#

# 3.26
因为二分查找时的开头会有变更，例如如果big=50，end=100时，中间位置应该是50+25=75，如果不加beg的话下一次迭代位置会变成25，则程序执行错误。
#

# 3.27
(a)合法。  
(b)合法。  
(c)合法。  
(d)不合法，字符数组形势存储时需要有/0作为结束符。
#

# 3.28
sa是空的，是string的数组形势，且只记录了地址，似乎没有值存在这个地址中；ia中的所有数都为0；sa2中不只是地址，而是已经存了空字符串在里面；ia2中的数字的随机的。
#

# 3.29
数组没有vector那么灵活，数组的扩展是受限制的，数组不能使用迭代器，数组的顺序访问我个人觉得应该会比vector快，且数组可以用指针。
#

# 3.30
当访问ia[10]的时候会出现数组越界。
#

# 3.31
见代码。
#

# 3.32
见代码。
#

# 3.33
不初始化的话scores数组的初始值就可能是随机的，就会导致程序出错。
#

# 3.34
将p1和p2指在同一个位置，但是我觉得直接用p1=p2就ok为啥还要那么麻烦。@huangmingchuan大神说任何情况下都合法，我也是想了半天不知道哪里不合法，不合法的情况除非p2就已经不合法，否则将p1指过来应该没啥问题。
#

# 3.35
见代码。
#

# 3.36
见代码。
#

# 3.37
hello
#

# 3.38
因为是地址相加，地址相加之后的地址指的是什么是不知道的，所以没有意义。
#

# 3.39
见代码。
#

# 3.40
见代码。
#

# 3.41
见代码。
#

# 3.42
见代码。
#

# 3.43
见代码。
#

# 3.44
见代码。
#

# 3.45
见代码。
#