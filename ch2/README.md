# 2.1
各类整数之间主要是所占位数的差别，所以能表示的整数范围有所不同。unsigned与他们的不同点在于没有首位的符号位。浮点数之间的差距在于单精度和双精度所占位数不同，能够表示的精度范围不同。
#

# 2.2
个人认为，利率选择float，本金选择unsigned double，付款选择unsigned float。
#

# 2.3
10
4294967264
32
-32
0
0
#

# 2.4
略。
#

# 2.5
（1）字符，宽字符，字符数组，宽字符字符数组。
（2）整数、无符号整数、长整数、无符号长整数、八进制整数、十六进制整数。
（3）双精度浮点数、浮点数、长双精度浮点数。
（4）整数、无符号整数、双精度浮点数、双精度浮点数。
#

# 2.6
09超出了八进制范围，应该是编译时直接报错的。
#

# 2.7
（a）字符数组类型。
（b）长双进度浮点数。
（c）单精度浮点数。
（d）长双精度浮点数。
#

# 2.8
见代码。
#

# 2.9
（a）>>的右值不能初始化变量；
（b）使用{}出现数值丢失的情况编译器会报错。
（c）wage作为右边=的左值是是未初始化的变量。
（d）强制转换double到int，将丢失小数位，但是编译不会报错。
#

# 2.10
global_str应该为“”
global_int应该为0
local_str应该为“”
local_int应该为未定义
#

# 2.11
（a）定义
（b）声明
（c）声明
#

# 2.12
（c）、（d）非法。
#

# 2.13
100
#

# 2.14
合法，45.
#

# 2.15
（d）非法，因为引用必须被初始化，需要提供一个绑定对象。
#

# 2.16
（a）d = 3.14159
（b）d = 0
（c）i = 0
（d）i = 0
#

# 2.17
10 10
#

# 2.18
见代码。
#

# 2.19
我感觉应该是指针可以改变所指对象，而引用不能吧？
@huangmingchuan：
1. 引用是另一个对象的别名，而指针本身就是一个对象。
2. 引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。而指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。
#

# 2.20
计算i * i并赋值给i
#

# 2.21
（a）非法，不能把double *指向int *。
（b）非法，指针指向了右值，而没有指向地址。
#

# 2.22
第一条表示p是非空指针。
第二条表示p指的值不为0。
#

# 2.23
不能，因为不能确定指针所指的位置是否是有意义的位置。
#

# 2.24
因为p是void类型指针，可以指向所有类型，而lp的类型是long与int不同，所以不能指向i。
#

# 2.25
(a)ip是一个指向int的指针，i是一个int，r是i的引用。
(b)i是int，ip是一个空指针。
(c)ip是一个指向int的指针，ip2是一个int。
#

# 2.26
(a)没有初始值。
(c)合法。
(d)改变sz时候不合法。
#

# 2.27
(a)不合法，r需要为const。
(b)合法。
(c)合法。
(d)合法。
(e)合法。
(f)不合法，需要初始值。
(g)合法。
#

# 2.28
(a)不能这么写，const的位置好像不能在逗号后面。
(b)同样的问题。
(c)不合法，ic没有初始值。
(d)不合法，没有初始值。
(e)不合法，没有初始值。
#

# 2.29
(a)合法。
(b)不合法，p1不是常量。
(c)不合法，p1不是常量。
(d)合法。
(e)合法。
(f)不合法，常量值不能更改。
#

# 2.30
v2底层，v1变量，p1、r1变量，p2底层，p3既是顶层又是底层，r2底层。
#

# 2.31
(a)不合法。
(b)不合法，p1不是底层，后一句合法。
(c)不合法，p1不是底层，p2是底层不能改变其值。
#

# 2.32
后一句改为 *p= &null;
#

# 2.33 2.34
见代码。
d是一个指针，赋值会出错。
e是一个指针，赋值会出错。
g是一个常量，不能改变其值。
#

# 2.35
i是整数常量，j是整数常量，k是整数常量的引用，p是底层常量指针，j2是整数常量，k2是整数常量的引用。
#

# 2.36
a = 4, b = 4, c = 4, d = 4。
#

# 2.37
@huangmingchuan：
c 是 int 类型，值为 3。d 是 int& 类型，绑定到 a。
#

# 2.38
@huangmingchuan：
decltype 处理顶层const和引用的方式与 auto不同，decltype会将顶层const和引用保留起来。
#

# 2.39
编译不通过，报错说struct后面需要有;。
#

# 2.40
见代码。
#

# 2.41
见代码。
#

# 2.42
见代码。
#