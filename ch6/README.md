# 6.1
实参是形参的初始值，形参本身在函数定义时候是没有值的，直到有实参传给形参。
#

# 6.2
(a)函数的返回值是int，却返回了string。  
(b)缺返回值声明。  
(c)缺返回值。  
(d)缺花括号。
#

# 6.3
见代码。
#

# 6.4
见代码。
#

# 6.5
见代码。
#

# 6.6
见代码。
#

# 6.7
见代码。
#

# 6.8
见代码。
#

# 6.9
见代码。
#

# 6.10
见代码。
#

# 6.11
见代码。
#

# 6.12
见代码，我觉得引用方便，代码量少了，不容易绕晕。
#

# 6.13
T传递T这个类型的实参拷贝给形参，在函数内改变T一般不会改变真实的T（T里有指针除外），而T&是传递引用，会被改变。
#

# 6.14
交换两个数的时候应该是引用，当函数调用对象不应该被修改时就不用引用。
#

# 6.15
因为s不应该被修改，而occurs是需要被修改的，s被设置为常量也是出于安全考虑，c虽然没有被修改不过可能会被修改，而如果occurs被定义为常量则程序会报错。
#

# 6.16
这题想表达什么？表达这个函数是多余的吗？= =、
#

# 6.17
见代码。
#

# 6.18
(a)bool compare(matrix a, matrix b);  
(b)vector<int>::iteratir change_val(int i, vector<int>::iteratir vi);
#

# 6.19
(a)calc只能有一个参数传入。  
(b)合法。  
(c)合法。  
(d)应该能用，3.8会被自动转为3传入函数。
#

# 6.20
实参是常数或者不可改变的时候要用常量引用，如果改为普通引用有时候会出错，比如说当类型是const int&时我传入常数值是可以编译通过的，因为有内存分配给他，而当类型是int &时传递常数就会出错，因为引用必须有引用的对象，不能引用常数值。
#

# 6.21
见代码。
#

# 6.22
见代码。
#

# 6.23
见代码。
#

# 6.24
这题没太明白，因为我编译以后是可以用的。
#

# 6.25
见代码。
#

# 6.26
见代码。
#

# 6.27
见代码。
#

# 6.28
是const string&类型。
#

# 6.29
应该声明为常量引用，initializer_list中的对象不能被修改，但是不严谨的来说好像不改也问题不大？反正他不能修改。
#

# 6.30
略。
#

# 6.31
返回的引用对象在函数中被销毁则无效，后面一问不知道。
#

# 6.32
合法。
#

# 6.33
见代码。
#

# 6.34
当val为负数时函数停不下来。
#

# 6.35
传val--会进入死循环，因为穿进去的val值没变。
#

# 6.36
string (*func(void))[10]
#

# 6.37
(1)typedef string string_vec[10]; string_vec* func(void);  
(2)auto func(void) -> string(*)[10];  
(3)decltype(string_list) *func(void);
#

# 6.38
decltype(odd)& arrPtr(int i);
#

# 6.39
(a)不合法，顶层const不影响传入函数，将会导致无法区分。  
(b)不合法，返回值不一致。  
(c)合法。
#

# 6.40
(a)正确。  
(b)有默认参数的形参必须放在没有默认参数的形参之后。
#

# 6.41
(a)非法。  
(b)合法。  
(c)非法，无法区分14传给谁。
#

# 6.42
没太看明白题目意思。
#

# 6.43
a放源文件，b放头文件。
#

# 6.44
加inline。
#

# 6.45
略。
#

# 6.46
不能，isShorter函数的参数类型不是字面值类型。
#

# 6.47
见代码。
#

# 6.48
不合理吧感觉，此时cin里是没有值的。
#

# 6.49
候选函数是与被调用函数同名的函数，可行函数是多个可以在给定实参的情况下匹配的函数。
#

# 6.50
a会有二义性，编译失败，其他都合法，c、d都是最佳匹配，b优先匹配f(int)。
#

# 6.51
略。
#

# 6.52
(a)char转int。  
(b)double转int。
#

# 6.53
a、b都会有冲突，因为顶层const对实参没有影响，c合法。
#

# 6.54
int func(int, int);
vector<decltype(func)*> v;
#

# 6.55
见代码。
#

# 6.56
见6.55代码。
#