# 10.1
见代码。
#

# 10.2
见代码。
#

# 10.3
见代码。
#

# 10.4
返回值会变成一个int类型。
#

# 10.5
会报错，因为C风格字符串没有==运算。
#

# 10.6
见代码。
#

# 10.7
(a)lst是空的，会发生错误。  
(b)似乎没问题。
#

# 10.8
因为本质上，标准库的算法并没有去改变长度，他只是执行相应的赋值操作，而是back_inserter这么一个特殊的迭代器，在接受标准库算法的赋值操作时进行了插入器的插入操作，所以改变了长度。
#

# 10.9
见代码。
#

# 10.10
基于安全性考虑吧，或者说有的容器并不支持改变大小的操作。
#

# 10.11
见代码。  
#

# 10.12
见代码。
#

# 10.13
见代码。
#

# 10.14
见代码。
#

# 10.15
见代码。
#

# 10.16
见代码。
#

# 10.17
见代码。
#

# 10.18
见代码。
#

# 10.19
见代码。
#

# 10.20
见代码。
#

# 10.21
见代码。
#

# 10.22
见代码。
#

# 10.23
接受参数为传入函数的参数数量 + 1。
#

# 10.24
见代码。
#

# 10.25
见代码。
#

# 10.26
back_inserter 使用 push_back 。  
front_inserter 使用 push_front 。  
inserter 使用 insert，此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。
#

# 10.27
见代码。
#

# 10.28
见代码。
#

# 10.29
见代码。
#

# 10.30
见代码。
#

# 10.31
见代码。
#

# 10.32
不合法，因为参数的求值顺序是未指定的。
#

# 10.33
见代码。
#

# 10.34
见代码。
#

# 10.35
见代码。
#

# 10.36
见代码。
#

# 10.37
见代码。
#

# 10.38
略。
#

# 10.39
list感觉应该是双向迭代器，vector应该是随机访问迭代器。
#

# 10.40
copy感觉应该需要前向迭代器，reverse双向迭代器，unique应该需要随机访问迭代器。
#

# 10.41
(1)用new_val替代[beg, end)中的old_val值。  
(2)在[beg, end)中如果满足pred则用new_val替代它的值。  
(3)用new_val替代[beg, end)中的old_val值，把结果拷贝到dest中。  
(4)在[beg, end)中如果满足pred则用new_val替代它的值，把结果拷贝到dest中。
#

# 10.42
见代码。
#