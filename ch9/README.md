# 9.1
(a)用vector先顺序放进去，再排序；如果说已经有现成的字典序文件的话应该用list更好。  
(b)forward_list。  
(c)用vector先顺序放进去，再排序。
#

# 9.2
list<deque<int>> i;
#

# 9.3
有两个迭代器begin和end，他们指向同一个容器中的元素，或者是容器最后一个元素之后的位置，且我们可以通过反复递增begin来达到end，所以end不在begin之前。
#

# 9.4
见代码。
#

# 9.5
见代码。
#

# 9.6
list的迭代器不能比较大小。
#

# 9.7
vector<int>::size_type
#

# 9.8
list<string>::const_iterator // 读  
list<string>::iterator // 写
#

# 9.9
cbegin返回的是const_iterator类型，begin返回的是iterator类型。
#

# 9.10
it1是vector<int>::iterator，it2是vector<int>::const_iterator，it3是vector<int>::const_iterator，it4是vector<int>::const_iterator。
#

# 9.11
(1)vector<int> v; 默认的vector，其中没有元素。  
(2)vector<int> v1(v2); v1中的元素与v2中的相同。  
(3)vector<int> v1 = v2; v1中的元素与v2中的相同。  
(4)vector<int> v1{1, 2, 3}; v1中的元素是1，2，3。  
(5)vector<int> v1 = {1, 2, 3}; v1中的元素是1，2，3。  
(6)vector<int> v1(3, 10); v1中的元素是10，10，10。  
#

# 9.12
接受一个容器的拷贝必须两个容器在类型上是相同的，而接受迭代器的拷贝可以让两个容器类型上不同，但是其元素内容可以互相转换即可。
#

# 9.13
用迭代器拷贝初始化，见代码。
#

# 9.14
见代码。
#

# 9.15
见代码。
#

# 9.16
见代码。
#

# 9.17
关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。
#

# 9.18
见代码。
#

# 9.19
见代码。
#

# 9.20
见代码。
#

# 9.21
程序不会报错，但是执行速度缓慢。
#

# 9.22
程序会无限循环。
#

# 9.23
这四个值是相同的。
#

# 9.24
见代码。
#

# 9.25
elem1与elem2相等则不会删除元素；如果elem2是尾后迭代器则从elem1删除后面所有元素；如果都是尾后迭代器，则不会删除元素。
#

# 9.26
见代码。
#

# 9.27
见代码。
#

# 9.28
见代码。
#

# 9.29
会将后面加入的75个值按照指初始化插入到容器vec中；会删除后面90个元素。
#

# 9.30
元素类型必须有一个默认构造函数。
#

# 9.31
因为forward_list没有insert成员，需要调用insert_after成员，见代码。
#

# 9.32
不合法，因为参数的求值顺序是未指定的。
#

# 9.33
会导致无限循环，如果不赋值给begin那么begin需要加2。
#

# 9.34
用来赋值vi中的奇数，程序会进入无限循环，因为数字奇数一直在增加，见代码。
#

# 9.35
capacity代表了vector可以容纳的元素数量，size代表了vector中现在有的元素数量。
#

# 9.36
不可能。
#

# 9.37
因为list不存在预分配的内存空间，array的空间是固定大小不会变。
#

# 9.38
见代码。
#

# 9.39
输入一堆word，然后把最终的svec中保存的元素的数量改为现有元素数量个1.5倍。
#

# 9.40
512；1024；1024；2048。
#

# 9.41
见代码。
#

# 9.42
全部读入到一个istringstream中，然后再初始化。
#

# 9.43
见代码。
#

# 9.44
见代码。
#

# 9.45
见代码。
#

# 9.46
见代码。
#

# 9.47
见代码。
#

# 9.48
npos。
#

# 9.49
见代码。
#

# 9.50
见代码。
#

# 9.51
见代码。
#

# 9.52
见代码。
#