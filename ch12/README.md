# 12.1
都有4个元素。
#

# 12.2
见代码。
#

# 12.3
不需要，因为需要改变其中的数据。
#

# 12.4
因为size_type类型的数本身就不会小于0。
#

# 12.5
有explicit会限制构造函数的灵活性，这里没比亚，因为用char*做初始化的时候比较方便。
#

# 12.6
见代码。
#

# 12.7
见代码。
#

# 12.8
返回值类型有错误。
#

# 12.9
用内置指针的版本会导致内存泄露，智能指针版本r2会被释放。
#

# 12.10
看起来似乎没啥问题。
#

# 12.11
会报错，因为不能给shared_ptr的初始化传递内置指针。
#

# 12.12
(a)合法。  
(b)合法。  
(c)不合法，不能给shared_ptr的初始化传递内置指针。  
(d)不合法，不能给shared_ptr的初始化传递内置指针。
#

# 12.13
会发生错误，因为get返回的指针不能被delete。
#

# 12.14
见代码。
#

# 12.15
见代码。
#

# 12.16
略。
#

# 12.17
(a)错误，unique_ptr必须指向new返回的指针上。  
(b)错误，unique_ptr必须指向new返回的指针上。  
(c)正确。  
(d)错误，unique_ptr必须指向new返回的指针上。  
(e)正确。  
(f)错误，unique_ptr必须指向new返回的指针上。  
#

# 12.18
因为shared_ptr如果要返回内置指针的话有get函数，并且有可能是多个指针指向同一个内存，如果提供release函数容易出错。
#

# 12.19
见代码。
#

# 12.20
见代码。
#

# 12.21
原来的更好，直观。
#

# 12.22
构造函数改为接受 const StrBlob & , 然后给 StrBlob 类添加两个 const 成员函数 cbegin 和 cend，返回ConstStrBlobPtr。
#

# 12.23
见代码。
#

# 12.24
见代码。
#

# 12.25
delete[] pa;
#

# 12.26
可以用关键词的类型来进行下标操作，返回的类型是这个关键字对应值的左值；map<string, int>就可以用string类型的关键字使用下标操作，然后返回int型的左值。
#

# 12.27
见代码。
#

# 12.28
见代码。
#

# 12.29
见代码，我倾向前一个版本，因为习惯。
#

# 12.30
见代码。
#

# 12.31
用vector的话需要自己去重，比较麻烦且效率不高，用set的话数据结构中自动去重了。
#

# 12.32
略。
#

# 12.33
见代码。
#